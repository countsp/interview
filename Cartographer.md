# Carto

1️⃣ 点云输入 (/scan or /laser)
↓
2️⃣ 数据预处理（滤波、时间校正）
↓
3️⃣ 运动估计（IMU/里程计）
↓
4️⃣ 扫描匹配（Scan Matching）
↓
5️⃣ 子图构建（Submap）
↓
6️⃣ 闭环检测 + 图优化（后端）
↓
7️⃣ 生成最终地图 + 轨迹





### 2️⃣ 数据预处理：

**降采样：**

按体素网格将点云划分成小立方体（voxel）每个体素只保留一个点（比如第一个、中心点等） voxel_filter_size = 0.05  -- 体素滤波精度

**运动畸变补偿：**

对位置（平移）部分进行线性插值

对方向（旋转）部分使用 SLERP 插值（用于四元数间平滑插值）



### 3️⃣ 运动估计

使用 IMU（角速度）插值出该时间点的预测朝向（旋转）

使用 odom 或 IMU 加速度估计位置（平移）

得到预测位姿 → 作为 Scan Matching 的初值



### 4️⃣ scan matching：

1. **Real-Time Correlative Scan Matching（粗匹配）**

   构建一个离散搜索窗口：平移 ±`x` cm 旋转 ±`θ` 角度

   使用离散栅格地图匹配，点云落在高概率栅格上的越多，得分越高

2. **Ceres Scan Matcher（非线性优化）**

​		在粗匹配结果附近，进一步微调位姿，使得当前帧点云与子图的概率栅格对齐得更精准。

我们把要优化的 **变量** 定义为当前帧的 3 自由度位姿：```p=[x,y,θ]```

**代价函数（Cost Function）** E(p)，包含两部分:  
$$
E(\mathbf{p}) \;=\;
\sum_{i=1}^N w_{\mathrm{occ}}\bigl(1 - P(\mathbf{p}\otimes \mathbf{q}_i)\bigr)^2
\;+\;
w_{\mathrm{trans}}\|\mathbf{t} - \mathbf{t}_0\|^2
\;+\;
w_{\mathrm{rot}}(\theta - \theta_0)^2
$$


**占据空间匹配残差**：让点云尽可能落在高概率栅格上

**与粗匹配位姿偏离惩罚**：防止解跑得太远



## 5️⃣ 子图构建（Submap）

- **始终同时维护两个 Submap**：
  - **旧子图（finished）**：已经插入足够多帧数据，不再接受新扫描，等待后端优化时使用。
  - **新子图（growing）**：刚创建，正在接收新的扫描数据。
- 当新子图收到的扫描数达到配置的 `num_range_data`（默认 90）后：
  1. 把这个“新”子图标记为“旧”，停止插入；
  2. 创建一个全新的空子图，加入到活跃列表，开始接收后续扫描。



用ceres优化后的变换 T 把已经做过运动补偿（畸变校正）和体素滤波的 `RangeData` 里的所有点 qi 转到子图的本地坐标系.
$$
p 
i
​
 =T 
 ⊗q 
i
​
$$
**射线跟踪**：把从 `origin` 到每个 `p_i` 的格子都减低占据概率（标为空）

**终点更新**：把 `p_i` 所在格子提高占据概率（标为实）



## log‑Odds 表示

- 对于一个格子的占据概率 p∈(0,1)，定义它的 log‑odds 为
  $$
  ℓ = \log\frac{p}{1 - p}
  $$
  

**经过（miss）**：用一个负的 log‑odds 增量 Δℓmiss<0降低 ℓ，相当于减小 p。

**终点（hit）**：用一个正的 log‑odds 增量 Δℓhit>0 增加 ℓ，相当于增大 p。



## 6️⃣ 闭环检测 + 图优化（后端）

​	随着机器人运动，前端积累的误差会让地图出现“漂移”——新绘制的子图与早先子图在真实环境中其实是同一位置，却在地图上不重合。闭环检测用来发现这种“回到老地方”的情况，给后端图优化提供约束，从而消除全局漂移。



​	闭环检测时，`ConstraintBuilder2D` 只会拿那些**时间上早于**当前子图 `S_current`、且它们的**中心（origin）与当前子图中心的欧式距离**落在阈值范围内（默认小于 `max_constraint_distance`、也可以配置一个最小距离阈值以避免太近的子图） 的已完成子图 `S_finished[j]` 来做匹配。

1. **粗匹配**（RT Correlative）得到初值和 `score_initial`；

2. Ceres 精调得到 `score_refined`；

3. 如果 score_refined ≥ min_score  , 则认为**检测到闭环**，会向后端 Pose Graph 添加一条跨子图约束；



## 图优化

Cartographer 将RangeData与活跃 Submap 的配准结果封装成一个 `Constraint`，类型标记为 **INTRA_SUBMAP**，内容包括：

- 子图节点索引` i`
- 该帧对应的轨迹节点索引` k`
- 测量变换 `Tscan→submap`
- 信息矩阵 `Ω`

后端每当 **插入了 N 个新的轨迹节点**（也就是完成 N 帧 RangeData 的 Intra‑Submap 约束后），就批量运行一次全局图优化。

这个参数由 Lua 配置中的`POSE_GRAPH.optimize_every_n_nodes = 35`控制。



# 难点

Submap 之间拼接不紧密、出现畸变时，通常是“帧间配准”或“子图 overlap”不够、或者后端优化约束松散导致的。

1.增加 Submap 间的重叠

```
TRAJECTORY_BUILDER_2D.submaps.num_range_data = 120  -- 默认 90，增大后每个 Submap 包含更多帧
```

2.调整后端优化节奏与约束

```
POSE_GRAPH.optimize_every_n_nodes = 20  -- 默认 35，改小可更频繁优化
```

### 整体思路

1. **前端**：保证每帧点云都能“正确”对齐到 Submap —— 调整 overlap、分辨率、粗匹配参数、传感器外参
2. **后端**：保证全局约束稳健 —— 增加优化频率、提高闭环置信度阈值、引入更多可靠约束（odom/IMU）



### FAQ

### 1. 简述从传感器数据到全局地图的完整流程

**参考回答：**
 “系统首先通过 ROS 接收 2D 激光雷达（`LaserScan`／`PointCloud2`）和可选的 IMU、里程计数据。前端（Local SLAM）先对激光数据做体素滤波和运动畸变补偿，然后用 IMU/里程计插值得到预测位姿，接着分两步做 Scan Matching：第一步 Real‑Time Correlative 粗匹配出近似位姿，第二步用 Ceres Solver 做非线性最小二乘微调。微调后的帧位姿和对应的点云通过射线跟踪插入到两个活跃子图（Submap）中，生成 Intra‑Submap 约束。并行地，Constraint Builder 对历史已完成子图做空间和时间门限筛选，尝试对候选子图做闭环匹配，生成 Inter‑Submap 约束。最后，后端 Pose Graph 收集所有约束，用 Levenberg–Marquardt 优化所有子图位姿，输出无漂移的全局栅格地图和轨迹。”

------

### 2. 为什么要同时维护两个活跃子图？

**参考回答：**
 “两个活跃子图可以平滑切换：

- **旧子图**（刚从 ‘growing’ 完成转为 ‘finished’）还要继续接收当前帧做匹配，保证对上一批帧的配准不被打断；
- **新子图**（刚创建）开始接收新一批扫描，构建下一个局部地图；
   这样无论子图何时切换，都不会漏掉任何一帧数据的 Intra‑Submap 约束，也保证了前端配准和后端优化的连续性。”

------

### 3. IMU、里程计和激光雷达各自的角色

**参考回答：**

- **激光雷达**：核心感知，用来构建局部子图和做 Scan Matching；
- **IMU**：提供高频角速度积分，用于预测旋转朝向和运动补偿；
- **里程计（Odom）**：提供平移位移初值，如果可用则优先用于插值预测，降低前端匹配搜索范围；
   三者融合在 `PoseExtrapolator` 中混合插值出每个扫描时间点的初始位姿，使粗匹配和补偿更精准。

------

### 4. 什么是 Real‑Time Correlative Scan Matching？

**参考回答：**
 “RTCSM 是一种在概率栅格地图上做**暴力搜索**的粗匹配方法：

- 在粗匹配初值周围，用平移 ±0.1 m、旋转 ±20° 构建离散候选位姿；
- 对每个候选，把点云投到子图的概率栅格上，累加落在高概率格子的概率值，再扣除与初值的偏移惩罚；
- 得分最高的候选作为粗匹配结果，能够在无里程计或初值较差时跳出局部最优。”

------

### 5. Ceres Scan Matcher 的残差函数如何构造？

**参考回答：**
 “Ceres 前端的残差包括两部分：

1. **空间匹配残差**   ri=wocc (1−P(ci))\;r_i=\sqrt{w_{occ}}\,(1-P(c_i))ri=wocc(1−P(ci))，对每个点查子图概率栅格 PPP，使点越落高概率格子误差越小；
2. **初值偏离惩罚**   rtrans=wtrans(x−x0),  rrot=wrot(θ−θ0)\;r_{\rm trans}=\sqrt{w_{trans}}(x-x_0),\;r_{\rm rot}=\sqrt{w_{rot}}(\theta-\theta_0)rtrans=wtrans(x−x0),rrot=wrot(θ−θ0)，防止优化跑离粗匹配初值太远。
    Ceres 自动微分算雅可比，用 LM 同时优化 x,y,θx,y,θx,y,θ。”

------

### 6. 为什么不用 ICP 或 NDT？

**参考回答：**
 “ICP 点对点匹配对初值依赖大且对稀疏点云（低频 2D 雷达）不鲁棒；NDT 对高斯场拟合也容易被动态物体或不规则场景干扰。相反，Cartographer 用概率栅格地图做匹配更耐噪声且能并行暴力搜索，再通过 Ceres 精调，兼顾实时性和精度。”

------

### 7. Submap 构建与关键参数如何选择？

**参考回答：**

- **`num_range_data`（默认 90）**：每个子图累积帧数，增大可提高重叠度，减少拼接错位；
- **`resolution`（默认 0.05 m）**：栅格大小，粗分辨率提高鲁棒性，细分辨率可提升精度；
- 构建时对每条激光射线做“空”与“实”更新（射线跟踪 + 终点标记），维护 log‑odds 地图。

------

### 8. 闭环检测候选子图如何筛选？

**参考回答：**
 “先按时间 (`t_j < t_current`) 和空间距离 (`min_radius < ‖C_j–C_current‖ < max_constraint_distance`，默认 15 m) 做门限过滤，再对剩余候选用 RTCSM 粗匹配和 Ceres 精调确认。这样既高效又避免把远距离或动态物体区域误判成闭环。”

------

### 9. 后端优化触发时机和频率？

**参考回答：**
 “后端按插入到 Pose Graph 的轨迹节点数触发，默认 `optimize_every_n_nodes = 35`。如果激光频率 10 Hz，就约每 3.5 s 一次；可根据计算资源和实时要求调小或调大。”

------

### 10. Submap 拼接出现扭曲时该如何排查？

**参考回答：**

1. 检查激光→基座、IMU→基座的外参是否正确；
2. 增加子图重叠（`num_range_data`）或放宽粗匹配搜索窗口；
3. 调整分辨率、`min_score` 和 `optimize_every_n_nodes`；
4. 引入或调高里程计/IMU 约束权重；
    一步步定位前端配准或后端约束松散的环节。