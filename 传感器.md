# 鱼眼去畸变
https://cloud.tencent.com/developer/article/2063602

# imu内参

**IMU 固有参数**：先用 Allan 方差法估计加速度计和陀螺仪的噪声密度（noise density）和随机游走（bias random walk），并在 `imu.yaml` 中定义这些统计属性，作为优化时的权重和噪声模型。

Allan 方差法是一种基于时域两样本方差的噪声分析工具，最初由 David W. Allan 提出，用于评估信号随平均时间 τ 变化时的稳定性。其核心思想是将连续时间序列分成长度为 τ 的重叠或非重叠簇，计算相邻两簇平均值差的方差：

$$\
sigma^2(\tau) \=\
\frac{1}{2\tau^2\(L - 2m)}
\sum_{k=1}^{L-2m}
\bigl(\theta_{k+2m} -2\theta_{k+m} +\theta_k\bigr)^2
$$

为了保证最后一项 $θk+2m$不越界（即 $k+2m≤L$)，k的最大值就必须是 $L−2m$

通过对 PSD 曲线不同斜率区间进行拟合，就能定量得到 IMU 的 **噪声密度（Noise Density）** 和 **随机游走系数（Random Walk）** 等参数。

### 噪声密度（Noise Density）

<img width="1018" height="398" alt="Screenshot from 2025-08-07 14-17-08" src="https://github.com/user-attachments/assets/a3a480e1-0d30-4723-a8a8-0445515660e1" />

### 随机游走（Rate/Accel Random Walk）
<img width="944" height="274" alt="Screenshot from 2025-08-07 14-16-17" src="https://github.com/user-attachments/assets/cc705f7b-c77d-4341-b333-261e56c855f8" />

# imu 相机外参
优化 **IMU 预积分误差** 和 **相机重投影误差**

1. IMU 预积分误差

场景：你在水平面上直线走了一小段路，IMU 记录了加速度和角速度，经过积分，它“估计”你从时刻 A 移动到了时刻 B，走了 0.5 米。

真实情况：其实你走了 0.45 米。


残差（误差）：
IMU 预测走 0.50 米，真实走 0.45 米，二者相差 0.05 米。

这个 0.05 米就是预积分残差的平移部分。

**测量量-预测量**
测量量（Measurement）是**加速度**积分出来的 v和p,预测量（Prediction）是上一时刻的上一时刻的估计速度 加上传感器的**速度**值。

2. 相机重投影误差的简单例子

场景：相机看同一个棋盘格角点，理论上依据相机位置和参数，这个角点应该投影到图像的像素坐标 (200, 150)。

检测结果：图像处理算法真正找到的角点在 (205, 152)。

残差（误差）：
横向误差：205 − 200 = 5 像素
纵向误差：152 − 150 = 2 像素

换句话说，相机“猜”这个点应该在哪儿，和“真”检测到的点相比，差了多少像素，就是它的重投影误差。

# imu驱动

在 CAN 总线（PF_CAN）上，创建一个不经过额外封装的原始套接字（SOCK_RAW），并且使用最基本的原始 CAN 协议（CAN_RAW）来收发帧

```
int sock = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (sock < 0) {
        perror("Socket");
        return 1;
    }
```

ifreq 是在 <net/if.h> 中定义的一个通用结构，用来在用户空间和内核空间之间传递接口相关的参数，比如接口名、接口索引、接口地址等。

将接口名 “can0” 拷贝到 ifr.ifr_name。这是告诉后续的 ioctl 调用哪一个接口。

用 SIOCGIFINDEX（“get interface index”）命令，查询 “can0” 在内核中的索引（一个整数）。内核会把结果填回 ifr.ifr_ifindex。


```
    struct ifreq ifr;
    strcpy(ifr.ifr_name, "can0");
    ioctl(sock, SIOCGIFINDEX, &ifr);
```

这是 SocketCAN 专用的地址结构，定义在 <linux/can.h> 中，用于 bind()、connect()、recvfrom()、sendto() 等。

清零整个结构，确保没有遗留的未初始化数据。

协议族（address family）：告诉内核这是一个 CAN 套接字地址。AF_CAN 与之前 socket() 中的 PF_CAN 是等价的。

将通过 ioctl 得到的接口索引赋给 can_ifindex，告诉内核“我要绑定到编号为 X 的那个接口”。

```
    struct sockaddr_can addr;
    memset(&addr, 0, sizeof(addr));
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
```

把套接字 sock 绑定到指定的 CAN 接口上。
```
    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("Bind");
        close(sock);
        return 1;
    }
```    


绑定成功后，所有通过 recv() 或 read() 读取到的数据都会是从 “can0” 接收到的 CAN 帧；

同理，用 send() 或 write() 发出的帧也会从 “can0” 发出去。

错误处理
如果 bind() 失败，打印错误并关闭套接字，退出程序。


# socket
socket(domain, type, protocol) 三个参数共同决定了你要做哪一种网络通信：

domain（又叫 protocol family，协议族）：比如 AF_INET/PF_INET（IPv4）、AF_INET6/PF_INET6（IPv6）、AF_UNIX（本地进程间通信）、以及这里的 AF_CAN/PF_CAN（CAN 总线）。

type：SOCK_STREAM（面向连接的字节流，如 TCP）、SOCK_DGRAM（无连接数据报，如 UDP）、SOCK_RAW（原始套接字，自己处理协议头）……

protocol：在同一个协议族、同一个类型下，还可以支持多个子协议，比如在 CAN 协议族里就有 CAN_RAW、CAN_BCM、CAN_ISOTP 等。


# 相机参数
**1. 焦距 𝑓**

含义：相机镜头的“放大倍数”，决定成像时物体在图像上投影的大小。

形式：一般在像素坐标系下用两个分量表示，𝑓𝑥 和 𝑓𝑦 ，分别对应水平方向和垂直方向上的等效焦距（单位：像素）。
**
2. 主点 (𝑐𝑥,𝑐𝑦)**

含义：理想情况下，光轴在成像面上的交点；数字相机里通常不正好落在图像中心，需要校准得到。

形式：在像素坐标系下给出横纵坐标（单位：像素）。

**3. 畸变系数**
由于镜头并非理想，光线经镜片折射后会产生径向和切向畸变，需要额外参数描述：

径向畸变（𝑘1,𝑘2,𝑘3）切向畸变（𝑝1,𝑝2）

**4. 相机内参矩阵 𝐾**

把以上参数组织成一个 3×3 矩阵：

$$
K \=\
\begin{bmatrix}
f_x & s   & c_x\\
0   & f_y & c_y\\
0   & 0   & 1
\end{bmatrix}
$$

